<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Duck Dimension Jumper</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #111; }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            pointer-events: none;
            z-index: 5;
        }
        .stat-card {
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 20px;
            border-radius: 12px;
            margin-bottom: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        #level-indicator { font-size: 24px; font-weight: bold; color: #ffeb3b; }
        #dimension-indicator { font-size: 14px; text-transform: uppercase; letter-spacing: 2px; }
        #coop-status { font-size: 12px; color: #4fc3f7; margin-top: 5px; }
        
        #controls-hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            text-align: center;
            z-index: 5;
            line-height: 1.4;
        }

        #menu-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: radial-gradient(circle, #2c3e50 0%, #000000 100%);
            color: white;
            z-index: 20;
            overflow-y: auto;
            padding: 40px 0;
        }

        .menu-content {
            text-align: center;
            max-width: 800px;
            width: 90%;
        }

        h1 { font-size: 48px; color: #ffeb3b; margin-bottom: 10px; }
        
        .btn-group { 
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin: 20px 0; 
        }

        button {
            padding: 15px 40px;
            font-size: 20px;
            background: #ffeb3b;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
            min-width: 250px;
        }
        button:hover { transform: scale(1.05); background: #fff176; }

        #level-select-container, #mode-select-container {
            margin-top: 20px;
            width: 100%;
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .level-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
            gap: 10px;
            margin-top: 15px;
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 15px;
            max-height: 300px;
            overflow-y: auto;
        }

        .level-btn {
            width: 50px;
            height: 50px;
            padding: 0;
            font-size: 14px;
            margin: 0;
            border-radius: 8px;
            background: rgba(255,255,255,0.2);
            color: white;
            min-width: auto;
        }
        .level-btn:hover { background: #ffeb3b; color: black; transform: scale(1.1); }

        .hidden { display: none !important; }

        #back-to-menu {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 15;
            padding: 8px 16px;
            font-size: 14px;
            background: rgba(255,255,255,0.2);
            color: white;
            pointer-events: auto;
            border: 1px solid white;
            border-radius: 8px;
            min-width: auto;
        }
    </style>
</head>
<body>
    <div id="ui" class="hidden">
        <div class="stat-card">
            <div id="level-indicator">Level 1</div>
            <div id="dimension-indicator">Dimension: 2D</div>
            <div id="coop-status" class="hidden">Waiting for both players...</div>
        </div>
    </div>
    
    <button id="back-to-menu" class="hidden">QUIT TO MENU</button>

    <div id="controls-hint" class="hidden">
        P1: WASD + SPACE | P2: Arrows + L | R to Restart<br>
        <span id="mouse-hint">Click to lock mouse & look around (3D Only) | ESC to unlock</span>
    </div>

    <div id="menu-overlay">
        <div class="menu-content">
            <h1 id="overlay-title">Duck Dimension Jumper</h1>
            <p id="overlay-desc">Jump through 100 levels of 2D and 3D challenges!</p>
            
            <div id="main-menu-btns" class="btn-group">
                <button id="play-btn">PLAY</button>
                <button id="toggle-levels-btn">LEVEL SELECT</button>
            </div>

            <div id="mode-select-container" class="btn-group hidden">
                <h3 id="mode-title">CHOOSE MODE</h3>
                <button id="1p-btn">1 PLAYER</button>
                <button id="2p-btn" style="background: #4fc3f7;">2 PLAYER (CO-OP)</button>
                <button id="cancel-mode-btn" style="background: transparent; color: white; border: 1px solid white; font-size: 14px; min-width: 100px;">Back</button>
            </div>
            
            <div id="level-select-container" class="hidden">
                <div class="btn-group">
                    <button id="cancel-level-btn" style="background: transparent; color: white; border: 1px solid white; font-size: 14px; min-width: 100px;">Back</button>
                </div>
                <h3>SELECT A LEVEL</h3>
                <div class="level-grid" id="level-grid"></div>
            </div>
        </div>
    </div>

    <script>
        // Game State
        let scene, camera, renderer, duck, parrot, goal;
        let platforms = [];
        let hazards = [];
        let level = 1;
        let pendingLevel = 1; 
        let is3D = false;
        let isTwoPlayer = false;
        let keys = {};
        
        let duckVel = new THREE.Vector3();
        let duckExtVel = new THREE.Vector2(0, 0); 
        let duckJumps = 0;
        let duckOnPlatform = null; 
        
        let parrotVel = new THREE.Vector3();
        let parrotExtVel = new THREE.Vector2(0, 0);
        let parrotJumps = 0;
        let parrotOnPlatform = null;
        
        let gameRunning = false;
        let yaw = 0, pitch = 0;
        let time = 0;
        
        const GRAVITY = 0.015;
        const JUMP_FORCE = 0.32;
        const SPEED = 0.14;
        const FRICTION = 0.92; 
        const SLIPPERY_FRICTION = 0.998; // Very slippery for Ice blocks

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const sun = new THREE.DirectionalLight(0xffffff, 0.8);
            sun.position.set(10, 20, 10);
            sun.castShadow = true;
            scene.add(sun);

            createDuck();
            createParrot();
            generateLevelSelect();

            window.addEventListener('keydown', (e) => {
                if (e.code === 'Space') handleJump('duck');
                if (e.code === 'KeyL') handleJump('parrot');
                if (e.code === 'KeyR' && gameRunning) loadLevel(level);
                keys[e.code] = true;
            });
            window.addEventListener('keyup', (e) => keys[e.code] = false);
            window.addEventListener('resize', onWindowResize);
            
            renderer.domElement.addEventListener('click', () => {
                if (is3D && gameRunning) renderer.domElement.requestPointerLock();
            });

            window.addEventListener('mousemove', (e) => {
                if (is3D && gameRunning && document.pointerLockElement === renderer.domElement) {
                    yaw -= e.movementX * 0.003;
                    pitch -= e.movementY * 0.003;
                    pitch = Math.max(-Math.PI / 2.5, Math.min(Math.PI / 4, pitch));
                }
            });
            
            document.getElementById('play-btn').onclick = () => {
                pendingLevel = 1;
                document.getElementById('mode-title').innerText = "CHOOSE MODE";
                document.getElementById('main-menu-btns').classList.add('hidden');
                document.getElementById('mode-select-container').classList.remove('hidden');
            };
            
            document.getElementById('cancel-mode-btn').onclick = () => {
                if (document.getElementById('level-select-container').getAttribute('data-active') === 'true') {
                    document.getElementById('mode-select-container').classList.add('hidden');
                    document.getElementById('level-select-container').classList.remove('hidden');
                } else {
                    document.getElementById('main-menu-btns').classList.remove('hidden');
                    document.getElementById('mode-select-container').classList.add('hidden');
                }
            };

            document.getElementById('1p-btn').onclick = () => { isTwoPlayer = false; startGame(pendingLevel); };
            document.getElementById('2p-btn').onclick = () => { isTwoPlayer = true; startGame(pendingLevel); };
            
            document.getElementById('toggle-levels-btn').onclick = () => {
                document.getElementById('main-menu-btns').classList.add('hidden');
                document.getElementById('level-select-container').classList.remove('hidden');
                document.getElementById('level-select-container').setAttribute('data-active', 'true');
            };

            document.getElementById('cancel-level-btn').onclick = () => {
                document.getElementById('main-menu-btns').classList.remove('hidden');
                document.getElementById('level-select-container').classList.add('hidden');
                document.getElementById('level-select-container').setAttribute('data-active', 'false');
            };

            document.getElementById('back-to-menu').onclick = showMenu;

            animate();
        }

        function generateLevelSelect() {
            const grid = document.getElementById('level-grid');
            for (let i = 1; i <= 100; i++) {
                const btn = document.createElement('button');
                btn.innerText = i;
                btn.className = 'level-btn';
                btn.onclick = () => {
                    pendingLevel = i;
                    document.getElementById('mode-title').innerText = `LEVEL ${i}: CHOOSE MODE`;
                    document.getElementById('level-select-container').classList.add('hidden');
                    document.getElementById('mode-select-container').classList.remove('hidden');
                };
                grid.appendChild(btn);
            }
        }

        function startGame(num) {
            level = num;
            gameRunning = true;
            document.getElementById('menu-overlay').classList.add('hidden');
            document.getElementById('mode-select-container').classList.add('hidden');
            document.getElementById('level-select-container').classList.add('hidden');
            document.getElementById('level-select-container').setAttribute('data-active', 'false');
            document.getElementById('ui').classList.remove('hidden');
            document.getElementById('back-to-menu').classList.remove('hidden');
            document.getElementById('controls-hint').classList.remove('hidden');
            
            const coopStatus = document.getElementById('coop-status');
            if (isTwoPlayer) coopStatus.classList.remove('hidden');
            else coopStatus.classList.add('hidden');
            
            loadLevel(level);
        }

        function showMenu() {
            gameRunning = false;
            document.getElementById('menu-overlay').classList.remove('hidden');
            document.getElementById('main-menu-btns').classList.remove('hidden');
            document.getElementById('mode-select-container').classList.add('hidden');
            document.getElementById('level-select-container').classList.add('hidden');
            document.getElementById('level-select-container').setAttribute('data-active', 'false');
            document.getElementById('ui').classList.add('hidden');
            document.getElementById('back-to-menu').classList.add('hidden');
            document.getElementById('controls-hint').classList.add('hidden');
            if (document.pointerLockElement) document.exitPointerLock();
        }

        function createDuck() {
            const group = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.5, 0.8), new THREE.MeshStandardMaterial({ color: 0xffeb3b }));
            body.position.y = 0.25; body.castShadow = true;
            group.add(body);
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), new THREE.MeshStandardMaterial({ color: 0xffeb3b }));
            head.position.set(0, 0.6, 0.3); head.castShadow = true;
            group.add(head);
            const beak = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.1, 0.2), new THREE.MeshStandardMaterial({ color: 0xff9800 }));
            beak.position.set(0, 0.55, 0.55);
            group.add(beak);
            duck = group; scene.add(duck);
        }

        function createParrot() {
            const group = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.6, 0.7), new THREE.MeshStandardMaterial({ color: 0x4caf50 }));
            body.position.y = 0.3; body.castShadow = true;
            group.add(body);
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.35, 0.35), new THREE.MeshStandardMaterial({ color: 0xf44336 }));
            head.position.set(0, 0.7, 0.25); head.castShadow = true;
            group.add(head);
            const beak = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.25, 0.2), new THREE.MeshStandardMaterial({ color: 0x333333 }));
            beak.position.set(0, 0.65, 0.45);
            group.add(beak);
            parrot = group;
            parrot.visible = false;
            scene.add(parrot);
        }

        function createPlatform(x, y, z, w, h, d, color = 0x4caf50, special = {}, index) {
            const geo = new THREE.BoxGeometry(w, h, d);
            const mat = new THREE.MeshStandardMaterial({ 
                color: color, 
                transparent: special.ice ? true : false,
                opacity: special.ice ? 0.7 : 1.0 
            });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, y, z);
            mesh.receiveShadow = true;
            scene.add(mesh);
            
            const plat = { 
                mesh, w, h, d, 
                index,
                initialPos: new THREE.Vector3(x, y, z),
                motion: special.motion || null,
                crumble: special.crumble || false,
                launch: special.launch || false,
                warp: special.warp || false,
                ice: special.ice || false,
                speed: special.speed || false,
                touched: false,
                crumbleTimer: 60,
                originalColor: color
            };

            if (plat.launch) {
                const pad = new THREE.Mesh(new THREE.BoxGeometry(w*0.8, 0.1, d*0.8), new THREE.MeshStandardMaterial({ color: 0x8b4513, emissive: 0x8b4513, emissiveIntensity: 0.3 }));
                pad.position.y = h/2 + 0.05;
                mesh.add(pad);
            }

            if (plat.speed) {
                const arrow = new THREE.Mesh(new THREE.BoxGeometry(w*0.6, 0.05, d*0.6), new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xffff00, emissiveIntensity: 1 }));
                arrow.position.y = h/2 + 0.05;
                mesh.add(arrow);
            }
            
            platforms.push(plat);
            return plat;
        }

        function createSpike(parent, ox, oy, oz) {
            const geo = new THREE.ConeGeometry(0.4, 0.8, 4);
            const mat = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(ox, oy + 0.4, oz);
            parent.add(mesh); 
            hazards.push(mesh);
        }

        function loadLevel(num) {
            platforms.forEach(p => scene.remove(p.mesh));
            hazards = []; 
            platforms = [];
            if (goal) scene.remove(goal);
            
            is3D = num % 2 === 0;
            document.getElementById('level-indicator').innerText = `Level ${num}`;
            document.getElementById('dimension-indicator').innerText = `Dimension: ${is3D ? '3D' : '2D'}`;
            document.getElementById('mouse-hint').style.display = is3D ? 'inline' : 'none';
            
            duckVel.set(0,0,0);
            duckExtVel.set(0,0);
            duck.position.set(0, 2, 0);
            duck.rotation.set(0,0,0);
            duckOnPlatform = null;
            
            parrot.visible = isTwoPlayer;
            if(isTwoPlayer) {
                parrotVel.set(0,0,0);
                parrotExtVel.set(0,0);
                parrot.position.set(0, 2, 1);
                parrot.rotation.set(0,0,0);
                parrotOnPlatform = null;
                document.getElementById('coop-status').innerText = "Waiting for Duck & Parrot...";
            }

            yaw = 0; pitch = 0;
            time = 0;
            scene.background = new THREE.Color(is3D ? 0x1a1a2e : 0x87ceeb);

            createPlatform(0, -0.5, 0, 6, 1, is3D ? 8 : 2, 0x388e3c, {}, 0);

            let lastX = 0, lastY = 0, lastZ = 0;
            const stepCount = 8 + Math.floor(num / 3);
            let finalPlat;

            for(let i = 1; i <= stepCount; i++) {
                let spreadX = 4.5 + Math.random() * 2.5; 
                let spreadY = (Math.random() - 0.25) * 3.5;
                let spreadZ = is3D ? (Math.random() - 0.5) * 8 : 0;
                
                const x = lastX + spreadX;
                const y = Math.min(Math.max(lastY + spreadY, lastY - 2.0), lastY + 3.0);
                const z = lastZ + spreadZ;
                const w = Math.max(2.5, 4.5 - (num / 35));
                const d = is3D ? Math.max(2.5, 4.5 - (num / 35)) : 2;
                
                let special = {};
                let color = 0x4caf50;

                const roll = Math.random();
                
                if (num >= 30 && roll < 0.1) {
                    special.warp = true;
                    color = 0x673ab7; 
                } else if (num >= 20 && roll < 0.25) {
                    special.speed = true;
                    color = 0xffff00; // Neon Yellow Speed Pad
                } else if (num >= 15 && roll < 0.4) {
                    special.ice = true;
                    color = 0xffffff; // White Ice Block
                } else if (num >= 25 && roll < 0.5) {
                    special.launch = true;
                    color = 0xa0522d; 
                } else if (num >= 20 && roll > 0.85) {
                    special.crumble = true;
                    color = 0xe91e63;
                } else if (num >= 15 && roll > 0.7) {
                    const isVertical = Math.random() > 0.5;
                    special.motion = {
                        axis: isVertical ? 'y' : 'x',
                        range: 2 + Math.random() * 3,
                        speed: 0.02 + Math.random() * 0.03,
                        offset: Math.random() * Math.PI * 2
                    };
                    color = 0x2196f3;
                }

                let plat = createPlatform(x, y, z, w, 0.5, d, color, special, i);
                
                if (num >= 5 && Math.random() > 0.4 && !special.crumble && !special.launch && !special.warp && !special.ice && !special.speed) {
                    createSpike(plat.mesh, (Math.random() - 0.5) * (w - 1), 0.25, (is3D ? (Math.random() - 0.5) * (d - 1) : 0));
                }
                
                lastX = x; lastY = y; lastZ = z;
                finalPlat = plat;
            }

            const goalGeo = new THREE.TorusGeometry(1, 0.2, 16, 32);
            goal = new THREE.Mesh(goalGeo, new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0xffd700, emissiveIntensity: 0.8 }));
            goal.position.set(finalPlat.mesh.position.x, finalPlat.mesh.position.y + 2.5, finalPlat.mesh.position.z);
            scene.add(goal);
        }

        function handleJump(char) {
            if (!gameRunning) return;
            if (char === 'duck' && duckJumps < 2) {
                duckVel.y = JUMP_FORCE;
                duckJumps++;
                duckOnPlatform = null;
            } else if (char === 'parrot' && isTwoPlayer && parrotJumps < 2) {
                parrotVel.y = JUMP_FORCE;
                parrotJumps++;
                parrotOnPlatform = null;
            }
        }

        function updateActor(actor, vel, extVel, jumpState, controls, isP1) {
            let mX = 0, mZ = 0;
            let moveInput = false;

            if (is3D) {
                const forward = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw));
                const right = new THREE.Vector3(Math.sin(yaw + Math.PI/2), 0, Math.cos(yaw + Math.PI/2));
                if (keys[controls.up]) { mX -= forward.x * SPEED; mZ -= forward.z * SPEED; moveInput = true; }
                if (keys[controls.down]) { mX += forward.x * SPEED; mZ += forward.z * SPEED; moveInput = true; }
                if (keys[controls.left]) { mX -= right.x * SPEED; mZ -= right.z * SPEED; moveInput = true; }
                if (keys[controls.right]) { mX += right.x * SPEED; mZ += right.z * SPEED; moveInput = true; }
            } else {
                if (keys[controls.left]) { mX = -SPEED; moveInput = true; }
                if (keys[controls.right]) { mX = SPEED; moveInput = true; }
                actor.position.z = isP1 ? 0 : 1;
            }

            const currentOnPlat = isP1 ? duckOnPlatform : parrotOnPlatform;
            const frictionToUse = (currentOnPlat && currentOnPlat.ice) ? SLIPPERY_FRICTION : FRICTION;
            
            extVel.x *= frictionToUse;
            extVel.y *= frictionToUse;

            if (moveInput) {
                extVel.x = THREE.MathUtils.lerp(extVel.x, mX, 0.2);
                extVel.y = THREE.MathUtils.lerp(extVel.y, mZ, 0.2);
            }

            actor.position.x += extVel.x;
            actor.position.z += extVel.y;
            
            if (Math.abs(extVel.x) > 0.01 || Math.abs(extVel.y) > 0.01) {
                actor.rotation.y = Math.atan2(extVel.x, extVel.y);
            }

            vel.y -= GRAVITY;
            actor.position.y += vel.y;

            if (currentOnPlat && currentOnPlat.motion) {
                const m = currentOnPlat.motion;
                const delta = Math.cos(time * m.speed + m.offset) * m.range * m.speed;
                if (m.axis === 'x') actor.position.x += delta;
                if (m.axis === 'y') actor.position.y += delta;
            }

            let foundPlatform = null;
            platforms.forEach(p => {
                if (!p.mesh.parent) return; 
                
                const dx = Math.abs(actor.position.x - p.mesh.position.x);
                const dy = actor.position.y - (p.mesh.position.y + p.h/2);
                const dz = Math.abs(actor.position.z - p.mesh.position.z);
                
                if (dx < (p.w/2 + 0.3) && dz < (p.d/2 + 0.3)) {
                    if (dy > -0.2 && dy < 0.5 && vel.y <= 0) {
                        actor.position.y = p.mesh.position.y + p.h/2 + 0.25;
                        vel.y = 0;
                        
                        if(isP1) { duckJumps = 0; duckOnPlatform = p; } 
                        else { parrotJumps = 0; parrotOnPlatform = p; }
                        
                        actor.rotation.z = 0;
                        foundPlatform = p;
                        
                        if (p.crumble) p.touched = true;
                        
                        if (p.launch) {
                            vel.y = 0.75; 
                            if(isP1) duckJumps = 1; else parrotJumps = 1;
                        }

                        if (p.speed) {
                           // Apply a strong horizontal push based on current direction
                           if (moveInput) {
                               extVel.x *= 1.8;
                               extVel.y *= 1.8;
                           } else {
                               extVel.x += 0.2; // Default nudge if standing still
                           }
                        }

                        if (p.warp && !p.touched) {
                            p.touched = true;
                            const targetIdxMin = p.index + 3;
                            const targetIdxMax = p.index + 5;
                            const safePlats = platforms.filter(plat => 
                                plat.index >= targetIdxMin && plat.index <= targetIdxMax &&
                                !plat.launch && !plat.warp && !plat.crumble && plat.mesh.parent
                            );
                            if (safePlats.length > 0) {
                                const randPlat = safePlats[Math.floor(Math.random() * safePlats.length)];
                                actor.position.set(randPlat.mesh.position.x, randPlat.mesh.position.y + 5, randPlat.mesh.position.z);
                            }
                        }
                    }
                }
            });
            
            if (!foundPlatform) {
                if (isP1) duckOnPlatform = null; else parrotOnPlatform = null;
            }

            hazards.forEach(h => { 
                const worldPos = new THREE.Vector3();
                h.getWorldPosition(worldPos);
                if (actor.position.distanceTo(worldPos) < 0.75) loadLevel(level); 
            });

            if ((isP1 ? duckJumps : parrotJumps) === 2) actor.rotation.z += 0.2;
            if (actor.position.y < -15) loadLevel(level);
        }

        function updatePhysics() {
            if (!gameRunning) return;
            time++;

            for (let i = platforms.length - 1; i >= 0; i--) {
                const p = platforms[i];
                if (!p.mesh.parent) continue;

                if (p.motion) {
                    const m = p.motion;
                    const offset = Math.sin(time * m.speed + m.offset) * m.range;
                    if (m.axis === 'x') p.mesh.position.x = p.initialPos.x + offset;
                    if (m.axis === 'y') p.mesh.position.y = p.initialPos.y + offset;
                }
                
                if (p.crumble && p.touched) {
                    p.crumbleTimer--;
                    p.mesh.position.x += (Math.random() - 0.5) * 0.15;
                    p.mesh.material.color.setHex(p.crumbleTimer % 6 < 3 ? 0xffffff : 0xe91e63);
                    if (p.crumbleTimer <= 0) scene.remove(p.mesh);
                }

                if (p.warp && p.touched) {
                    p.mesh.material.opacity = Math.max(0, p.mesh.material.opacity - 0.05);
                    p.mesh.material.transparent = true;
                }
            }

            const lastPlat = platforms[platforms.length - 1];
            if (lastPlat && lastPlat.mesh.parent) {
                goal.position.set(lastPlat.mesh.position.x, lastPlat.mesh.position.y + 2.5, lastPlat.mesh.position.z);
            }

            updateActor(duck, duckVel, duckExtVel, duckJumps, { up: 'KeyW', down: 'KeyS', left: 'KeyA', right: 'KeyD' }, true);
            
            if(isTwoPlayer) {
                updateActor(parrot, parrotVel, parrotExtVel, parrotJumps, { up: 'ArrowUp', down: 'ArrowDown', left: 'ArrowLeft', right: 'ArrowRight' }, false);
            }

            const duckAtGoal = duck.position.distanceTo(goal.position) < 2.5;
            const parrotAtGoal = isTwoPlayer ? parrot.position.distanceTo(goal.position) < 2.5 : true;

            if (isTwoPlayer) {
                const status = document.getElementById('coop-status');
                if (duckAtGoal && !parrotAtGoal) {
                    status.innerText = "Duck is READY! Waiting for Parrot...";
                    goal.material.emissive.setHex(0x00ff00); 
                } else if (!duckAtGoal && parrotAtGoal) {
                    status.innerText = "Parrot is READY! Waiting for Duck...";
                    goal.material.emissive.setHex(0x00ff00);
                } else if (duckAtGoal && parrotAtGoal) {
                    status.innerText = "GOAL REACHED!";
                    nextLevel();
                } else {
                    status.innerText = "Waiting for Duck & Parrot...";
                    goal.material.emissive.setHex(0xffd700);
                }
            } else {
                if (duckAtGoal) nextLevel();
            }
        }

        function nextLevel() {
            level++;
            if (level > 100) showWin(); else loadLevel(level);
        }

        function updateCamera() {
            if (!gameRunning) {
                camera.position.set(10 * Math.sin(Date.now() * 0.0005), 5, 10 * Math.cos(Date.now() * 0.0005));
                camera.lookAt(0, 0, 0);
                return;
            }

            let lookTarget = duck.position.clone();
            if(isTwoPlayer) {
                lookTarget.add(parrot.position).multiplyScalar(0.5);
            }

            if (is3D) {
                const dist = 12;
                const targetCamPos = new THREE.Vector3(
                    lookTarget.x + dist * Math.sin(yaw) * Math.cos(pitch),
                    lookTarget.y + 4 + dist * Math.sin(pitch),
                    lookTarget.z + dist * Math.cos(yaw) * Math.cos(pitch)
                );
                camera.position.lerp(targetCamPos, 0.1);
                camera.lookAt(lookTarget.x, lookTarget.y + 1, lookTarget.z);
            } else {
                camera.position.lerp(new THREE.Vector3(lookTarget.x, lookTarget.y + 2, 18), 0.1);
                camera.lookAt(lookTarget.x, lookTarget.y + 1, 0);
            }
        }

        function showWin() {
            document.getElementById('overlay-title').innerText = "AVIAN ASCENSION!";
            document.getElementById('overlay-desc').innerText = "The dimension is saved.";
            showMenu();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            updatePhysics();
            updateCamera();
            if (goal) { goal.rotation.y += 0.05; goal.rotation.z += 0.02; }
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
